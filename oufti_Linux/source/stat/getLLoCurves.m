function [dataStr,hdl] = getLLoCurves(cellList,varargin)
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% function [dataStr,hdl] = getLLoCurves(cellList,varargin)
%
% @authors: Manuel Campos
% @dat:     December 29 2014
% @copyright 2014-2015 Yale University
%==========================================================================
%**********OUTPUT**********
%dataStr:        A structure with 7 fields:
%                   -id:        array of cell ids of the whole time-lapse
%                   -Lbirth:    array of length at birth in pixels
%                   -lengthes:  cell array of arrays of cell lengthes
%                           organized by cell (growth curves). Each entry
%                           corresponds to one cell (cell id in id array)
%                   -frames:    cell array of arrays of frames in which
%                           cells are detected. Each entry correspond to 
%                           one cell.
%                   -cct:       array of cell cycle times in frames
%                   -gRates:    array of growth rates calculated from the
%                           growth curves, in pixel/frame.
%                   -rmseFit:   Root mean square error of the growth rate
%                           fit after re-fitting excluding all points 2 SD
%                           away from the initial fitted curve.
%hdl:           handle of the figure generated by curveGraph.m
%==========================================================================
%**********INPUT*********** 
% cellList: cellList of a time lapse. No need to compute cell lengthes
%           in advance. 
% varargin: Possibility to generate a graph with actual lengthes (in
%           pixels, not normalized by the length at birth) by setting a
%           logical to 0. The default is 1 and cell lengthes are normalized
% 
% Example:
% [dataStr,hh] = getLLoCurves(cellList,0); (non-normalized cell lengthes)
% OR
% [dataStr,hh] = getLLoCurves(cellList,1); (normalized cell lengthes by Lbirth)
% Which is equivalent to [dataStr,hh] = getLLoCurves(cellList);

w = waitbar(0, 'Extracting cell length data, please wait...');

% dataStr=struct('lengthes',{},'frames',{},'gRates',[],'cct',[],'Lbirth',[]);
if nargin==1
    normLog=1;
elseif nargin==2
    normLog=varargin{1};
elseif nargin == 3
    normLog = varargin{1};
    forceGrey = varargin{2};
else
    disp('Incorrect number of input variables');
    L={};T={};hdl=0;
    return
end

ID=[];
for ii=1:length(cellList.cellId)
    ID=[ID,cellList.cellId{ii}];
    ID=unique(ID);
end
dataStr.id=ID;

presenceMat=zeros(max(ID),length(cellList.meshData));
checkFrames=cellfun(@(x) length(x),cellList.meshData,'un',1);
goodFrames=checkFrames>0;
for frame = 1:length(cellList.meshData)
    if goodFrames(frame)
        [~, cellId] = oufti_getFrame(frame,cellList);
        presenceMat(cellId,frame)=1;
    end
end


for ii=1:length(ID)
    livFr=find(presenceMat(ID(ii),:)==1);
    L=zeros(length(livFr),1);
    for jj=1:length(livFr)
        livCell=cellList.cellId{livFr(jj)}==ID(ii);
        if isfield(cellList.meshData{livFr(jj)}{livCell},'mesh') && length(cellList.meshData{livFr(jj)}{livCell}.mesh)>4
            mesh=cellList.meshData{livFr(jj)}{livCell}.mesh;
            steplength = edist(mesh(2:end,1)+mesh(2:end,3),mesh(2:end,2)+mesh(2:end,4),...
                               mesh(1:end-1,1)+mesh(1:end-1,3),mesh(1:end-1,2)+mesh(1:end-1,4))/2;
            L(jj)=sum(steplength);
        end
    end
    dataStr.Lbirth(ii)=L(1);
    if normLog 
        L=L./L(1); 
    end
    T=livFr';
    dataStr.lengthes{ii}=L;
    dataStr.frames{ii}=livFr;
    dataStr.cct(ii)=length(livFr);
    dataStr.gRates(ii)=0;
    ix=~isnan(L) & L>0;
    XX=T(ix);
    YY=log(L(ix));
    if length(YY)>2
        ft = fittype( 'poly1' );
        [~,~,R]=fit(XX,YY,ft);
        inliers=(abs(R.residuals)<2*std(R.residuals));
        [Lf,gof]=fit(XX(inliers),YY(inliers),ft);
        dataStr.gRates(ii)=Lf.p1;
        dataStr.rmseFit(ii)=gof.rmse;
    end
    dLL=diff(log(L./L(1)));
    dataStr.rmsd(ii)=mean(sqrt((dLL-median(dLL)).^2));
    waitbar(ii/length(ID));
end
dataStr.frames=dataStr.frames';
dataStr.lengthes=dataStr.lengthes';

hdl = curveGraph(dataStr.frames,dataStr.lengthes,[],forceGrey);
% hdl = curveGraph(T,L,[]);

% AA=cellfun(@(x) x(1),L.lengthes,'un',1);
% check0=cellfun(@(x) sum(x),L,'un',1);
close(w);
end


function d=edist(x1,y1,x2,y2)
    % complementary for "getextradata", computes the length between 2 points
    d=sqrt((x2-x1).^2+(y2-y1).^2);
end

